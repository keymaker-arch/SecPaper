//! JSON file provider implementation.
//!
//! This module provides a simple provider that reads paper metadata from a JSON file.
//! This is useful for testing and for ingesting pre-collected datasets.

use async_trait::async_trait;
use serde::Deserialize;
use std::path::PathBuf;
use tokio::fs;

use crate::models::{Author, Paper};
use super::{PaperProvider, ProviderError, ProviderResult};

/// JSON file provider for paper metadata.
///
/// This provider reads papers from a JSON file containing an array of paper objects.
///
/// # File Format
///
/// The JSON file should contain an array of objects with the following structure:
/// ```json
/// [
///   {
///     "title": "Paper Title",
///     "authors": [
///       {"name": "Author Name", "affiliation": "University"}
///     ],
///     "abstract_text": "Paper abstract...",
///     "publish_year": 2023
///   }
/// ]
/// ```
pub struct JsonFilePaperProvider {
    /// Path to the JSON file
    _file_path: PathBuf,
    /// Deserialized paper data
    papers: Vec<Paper>,
}

/// Raw paper data from JSON input (may have different field names).
#[derive(Debug, Deserialize)]
struct JsonPaper {
    title: String,
    authors: Vec<JsonAuthor>,
    #[serde(alias = "abstract", alias = "abstract_text")]
    abstract_text: String,
    #[serde(alias = "year", alias = "publish_year")]
    publish_year: i32,
}

/// Raw author data from JSON input.
#[derive(Debug, Deserialize)]
struct JsonAuthor {
    name: String,
    #[serde(default)]
    affiliation: Option<String>,
}

impl JsonFilePaperProvider {
    /// Create a new JSON file provider by loading and deserializing papers from a file.
    ///
    /// # Arguments
    /// * `file_path` - Path to the JSON file containing paper metadata
    ///
    /// # Returns
    /// A new `JsonFilePaperProvider` instance with papers loaded into memory
    ///
    /// # Errors
    /// Returns `ProviderError` if the file doesn't exist, can't be read, or contains invalid JSON
    pub async fn from_file(file_path: PathBuf) -> ProviderResult<Self> {
        // Validate the file exists
        if !file_path.exists() {
            return Err(ProviderError::ConfigError(
                format!("File does not exist: {:?}", file_path)
            ));
        }
        
        // Read the JSON file
        let content = fs::read_to_string(&file_path).await?;
        
        // Parse the JSON
        let json_papers: Vec<JsonPaper> = serde_json::from_str(&content)
            .map_err(|e| ProviderError::ParseError(format!("Failed to parse JSON: {}", e)))?;
        
        // Convert to Paper structs
        let papers = json_papers
            .into_iter()
            .map(|jp| Paper {
                id: None, // ID will be assigned by storage
                title: jp.title,
                authors: jp.authors
                    .into_iter()
                    .map(|ja| Author {
                        name: ja.name,
                        affiliation: ja.affiliation,
                    })
                    .collect(),
                abstract_text: jp.abstract_text,
                publish_year: jp.publish_year,
                embedding: None, // Embeddings are generated by the ingestion pipeline
            })
            .collect();
        
        Ok(Self { _file_path: file_path, papers })
    }
}

#[async_trait]
impl PaperProvider for JsonFilePaperProvider {
    async fn fetch_papers(&self) -> ProviderResult<Vec<Paper>> {
        // Return a clone of the stored papers
        Ok(self.papers.clone())
    }
    
    async fn count_papers(&self) -> ProviderResult<usize> {
        // Return the count of stored papers
        Ok(self.papers.len())
    }
    
    fn name(&self) -> &str {
        "JSON File Provider"
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use tempfile::NamedTempFile;
    
    #[tokio::test]
    async fn test_json_provider_fetch_papers() {
        // Create a temporary JSON file
        let mut temp_file = NamedTempFile::new().unwrap();
        let json_data = r#"[
            {
                "title": "Test Paper 1",
                "authors": [
                    {"name": "Alice", "affiliation": "MIT"}
                ],
                "abstract_text": "This is a test abstract.",
                "publish_year": 2023
            },
            {
                "title": "Test Paper 2",
                "authors": [
                    {"name": "Bob", "affiliation": null}
                ],
                "abstract": "Another abstract.",
                "year": 2024
            }
        ]"#;
        write!(temp_file, "{}", json_data).unwrap();
        
        // Create provider and fetch papers
        let provider = JsonFilePaperProvider::from_file(temp_file.path().to_path_buf()).await.unwrap();
        let papers = provider.fetch_papers().await.unwrap();
        
        // Verify results
        assert_eq!(papers.len(), 2);
        assert_eq!(papers[0].title, "Test Paper 1");
        assert_eq!(papers[0].authors[0].name, "Alice");
        assert_eq!(papers[0].publish_year, 2023);
        assert!(papers[0].embedding.is_none());
        
        assert_eq!(papers[1].title, "Test Paper 2");
        assert_eq!(papers[1].publish_year, 2024);
    }
    
    #[tokio::test]
    async fn test_json_provider_count_papers() {
        let mut temp_file = NamedTempFile::new().unwrap();
        let json_data = r#"[
            {"title": "P1", "authors": [], "abstract_text": "A1", "publish_year": 2023},
            {"title": "P2", "authors": [], "abstract_text": "A2", "publish_year": 2024}
        ]"#;
        write!(temp_file, "{}", json_data).unwrap();
        
        let provider = JsonFilePaperProvider::from_file(temp_file.path().to_path_buf()).await.unwrap();
        let count = provider.count_papers().await.unwrap();
        
        assert_eq!(count, 2);
    }
    
    #[tokio::test]
    async fn test_json_provider_validate() {
        let mut temp_file = NamedTempFile::new().unwrap();
        write!(temp_file, "[]").unwrap();
        
        let provider = JsonFilePaperProvider::from_file(temp_file.path().to_path_buf()).await;
        assert!(provider.is_ok());
        
        // Test with non-existent file
        let result = JsonFilePaperProvider::from_file(PathBuf::from("/nonexistent/file.json")).await;
        assert!(result.is_err());
    }
}
